using System;
using System.Collections.Generic;
using System.IO;
using Vs.Graph.Abstractions.IO;
using Vs.Graph.Abstractions.Structure;
using Vs.Graph.Abstractions.Structure.Meta;

namespace Vs.Graph.Parsers.GraphML
{
    /// <summary>
    /// Class serialies a graph in GraphML format.
    /// 
    /// GraphML description can be found here: http://graphml.graphdrawing.org/specification/index.html
    /// 
    /// implemented:
    /// + store (un)directed graph
    /// + store vertices
    /// + store (un)directed edges
    /// + store partitions
    /// 
    /// not implemented:
    /// - attributes
    /// - hyperedges
    /// - nested graphs
    /// - graph meta
    /// 
    /// author:         Martin Junghanns (martin.junghanns@gmx.net)
    /// </summary>
    public class GraphMLWriter : IGraphWriter
    {
        private bool _UseShortLabels;

        private StreamWriter _StreamWriter;

        /// <summary>
        /// used if UseShortLabels is true
        /// stores the uuid and a corresponding integer
        /// used to retrieve the corrent integer when writing edges
        /// </summary>
        private Dictionary<string, long> _VertexIntMapper;

        /// <summary>
        /// stores all needed informations to write additional attributes to graphml
        /// string - AttributeID (f.e. "lon")
        /// Tuple<string, string, string> - AttributeName (f.e. "longitude"), Datatype (f.e. "double"), AttributeTarget (f.e. "node")
        /// </summary>
        private struct AdditionalAttribute
        {
            public string Datatype;
            public string AttributeName;
            public string AttributeTarget;
            public string Default;

            public AdditionalAttribute(string myDatatype, string myAttributeName, string myAttributeTarget, string myDefault = "")
            {
                Datatype = myDatatype;
                AttributeName = myAttributeName;
                AttributeTarget = myAttributeTarget;
                Default = myDefault;
            }
        }

        private Dictionary<string, AdditionalAttribute> _AdditionalAttributes;

        private long _ID;

        public GraphMLWriter(bool myUseShortLabels = false)
        {
            _UseShortLabels = myUseShortLabels;
            _VertexIntMapper = new Dictionary<string, long>();
            _AdditionalAttributes = new Dictionary<string, AdditionalAttribute>();
        }

        /// <summary>
        /// Adds additional attributes, which are used and added in the graphML file.
        /// </summary>
        /// <param name="myAttributeID">A short name/id of the attribute.</param>
        /// <param name="myDatatype">The Datatype of the attribute (The type of the GraphML-Attribute can be either boolean, int, long, float, double, or string).</param>
        /// <param name="myAttributeName">NOTE! The AttributeName has to be the same name of the corresponding attribute!</param>
        /// <param name="myAttributeTarget">The element of the graph to which the attribute belongs (f.e. node, graph ..).</param>
        public void AddAttribute(string myAttributeID, string myDatatype, string myAttributeName, string myAttributeTarget, string myDefault = "")
        {
            if (myDatatype.ToLower().Equals("double")
                || myDatatype.ToLower().Equals("int")
                || myDatatype.ToLower().Equals("boolean")
                || myDatatype.ToLower().Equals("long")
                || myDatatype.ToLower().Equals("float")
                || myDatatype.ToLower().Equals("string"))
            {
                _AdditionalAttributes.Add(myAttributeID.ToLower(), new AdditionalAttribute(myDatatype.ToLower(), myAttributeName, myAttributeTarget.ToLower(), myDefault));
            }
        }

        private bool Initialize(string myLocation)
        {
            try
            {
                _StreamWriter = new StreamWriter(myLocation);
            }
            catch (Exception e)
            {
                throw e;
            }

            _ID = 0L;

            return true;

        }

        private void Shutdown()
        {
            _StreamWriter.Flush();
            _StreamWriter.Close();
        }

        private void WriteGraphMLHeader()
        {
            #region header

            _StreamWriter.WriteLine("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
            _StreamWriter.WriteLine("<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\"");
            _StreamWriter.WriteLine("   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"");
            _StreamWriter.WriteLine("   xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns");
            _StreamWriter.WriteLine("   http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">");
            _StreamWriter.WriteLine("<!-- Graph generated by sones GraphAPI GraphMLWriter -->");

            #endregion
        }

        private void WriteGraphHeader(bool myIsDirected = false)
        {
            #region graph header

            if (myIsDirected)
            {
                // <graph id="G" edgedefault="directed">
                _StreamWriter.WriteLine("<{0} {1}=\"G\" {2}=\"{3}\">",
                    GraphMLTokens.GRAPH, GraphMLTokens.ID, GraphMLTokens.EDGEDEFAULT, GraphMLTokens.DIRECTED);
            }
            else
            {
                // <graph id="G" edgedefault="undirected">
                _StreamWriter.WriteLine("<{0} {1}=\"G\" {2}=\"{3}\">",
                    GraphMLTokens.GRAPH, GraphMLTokens.ID, GraphMLTokens.EDGEDEFAULT, GraphMLTokens.UNDIRECTED);
            }

            #endregion
        }

        private void WriteAdditionalAttributesDefinition()
        {
            #region addtitional attributes

            if (_AdditionalAttributes.Keys.Count > 0)
            {
                foreach (var id in _AdditionalAttributes.Keys)
                {
                    var value = _AdditionalAttributes[id];

                    _StreamWriter.WriteLine("<key id=\"{0}\" for=\"{1}\" attr.name=\"{2}\" attr.type=\"{3}\">",
                        id, value.AttributeTarget, value.AttributeName, value.Datatype);

                    if (!value.Default.Equals(""))
                    {
                        _StreamWriter.WriteLine("<default>" + value.Default + "</default>");
                    }

                    _StreamWriter.WriteLine("</key>");
                }
            }

            #endregion
        }

        private void WriteAdditionalAttributesContent(string myAttributeTarget, IDBObject myObject)
        {
            foreach (var id in _AdditionalAttributes.Keys)
            {
                var value = _AdditionalAttributes[id];

                if (value.AttributeTarget.Equals(myAttributeTarget))
                {
                    if (myObject.Attributes.ContainsKey(value.AttributeName))
                    {
                        //<data id="..">..</data>
                        _StreamWriter.WriteLine("           <{0} {1}=\"{2}\">{3}{4}",
                            GraphMLTokens.DATA, GraphMLTokens.KEY, id, myObject.Attributes[value.AttributeName].ToString(), GraphMLTokens.DATA_END_TAG);
                    }
                }
            }
        }

        private void WriteGraphFooter()
        {
            // </graph>
            _StreamWriter.WriteLine("   " + GraphMLTokens.END_GRAPH_TAG);
        }

        private void WriteFooter()
        {
            // </graph>
            // </graphml>
            _StreamWriter.WriteLine(GraphMLTokens.END_GRAPH_TAG);
            _StreamWriter.WriteLine(GraphMLTokens.END_GRAPHML_TAG);
        }

        public bool Write(IGraph myGraph, string myLocation)
        {
            try
            {
                Initialize(myLocation);

                #region header

                WriteGraphMLHeader();

                #endregion

                #region additional attributes

                WriteAdditionalAttributesDefinition();

                #endregion

                #region graph header

                WriteGraphHeader(myGraph.IsDirected);

                #endregion

                #region content

                WriteContent(myGraph.Vertices, myGraph.Edges);

                #endregion

                #region footer

                WriteFooter();

                #endregion

            }
            catch (Exception e)
            {
                throw e;
            }
            finally
            {
                Shutdown();
            }

            return true;
        }

        private void WriteContent(IEnumerable<IVertex> myVertices, IEnumerable<IEdge> myEdges)
        {
            #region vertices

            if (myVertices != null)
            {
                foreach (var vertex in myVertices)
                {
                    //<node>
                    _StreamWriter.WriteLine("       <{0} {1}=\"{2}\">", GraphMLTokens.VERTEX, GraphMLTokens.ID, _ID);

                    //<data> if existing
                    WriteAdditionalAttributesContent("node", vertex);

                    //</node>
                    _StreamWriter.WriteLine("       " + GraphMLTokens.NODE_END_TAG);

                    if (_UseShortLabels)
                    {
                        //store the uuid and the id to get the correct id when storing the edges
                        _VertexIntMapper.Add(vertex.UUID, _ID);

                        _ID++;
                    }
                }
            }

            #endregion

            #region edges

            if (myEdges != null)
            {
                foreach (var edge in myEdges)
                {
                    //<edge source="" target="">
                    _StreamWriter.WriteLine("       <{0} {1}=\"{2}\" {3}=\"{4}\">",
                        GraphMLTokens.EDGE, GraphMLTokens.SOURCE,
                        _UseShortLabels ? _VertexIntMapper[edge.Source.UUID].ToString() : edge.Source.UUID,
                        GraphMLTokens.TARGET,
                        _UseShortLabels ? _VertexIntMapper[edge.Target.UUID].ToString() : edge.Target.UUID);

                    //<data> if existing
                    WriteAdditionalAttributesContent("edge", edge);

                    //</edge>
                    _StreamWriter.WriteLine("       " + GraphMLTokens.EDGE_END_TAG);
                }
            }

            #endregion
        }

        //public bool WritePartitions(IEnumerable<IPartition> myPartitions, string myLocation)
        //{
        //    try
        //    {
        //        #region data / init

        //        Initialize(myLocation);

        //        var graph = myPartitions.First().Graph;
        //        var partitionCount = 0L;

        //        WriteGraphMLHeader();

        //        WriteAdditionalAttributesDefinition();

        //        WriteGraphHeader(_UseShortLabels);

        //        #endregion

        //        #region content

        //        #region partitions

        //        foreach (var partition in myPartitions)
        //        {
        //            //<node id="subgraph..">
        //            _StreamWriter.WriteLine("   <{0} {1}=\"subgraph{2}\">",
        //                GraphMLTokens.VERTEX, GraphMLTokens.ID, partitionCount.ToString());

        //            //<graph id="subgraph..">
        //            _StreamWriter.WriteLine("   <{0} {1}=\"subgraph{2}\">",
        //                GraphMLTokens.GRAPH, GraphMLTokens.ID, partitionCount.ToString());

        //            //<!-- partition #.. |E_ext|=.. |E_int|=.. -->
        //            _StreamWriter.WriteLine("   {0} partition #{1} |E_ext|={2} |E_int|={3} {4}",
        //                GraphMLTokens.COMMENT_BEGIN_TAG, partitionCount.ToString(),
        //                partition.GetExternalEdges().LongCount(),
        //                partition.GetInternalEdges().LongCount(),
        //                GraphMLTokens.COMMENT_END_TAG);

        //            //content
        //            WriteContent(partition.Vertices, partition.GetInternalEdges());

        //            //</graph>
        //            WriteGraphFooter();

        //            //</node>
        //            _StreamWriter.WriteLine("   " + GraphMLTokens.NODE_END_TAG);

        //            partitionCount++;
        //        }

        //        #endregion

        //        #region cut edges

        //        foreach (var partition in myPartitions)
        //        {
        //            WriteContent(null, partition.GetExternalEdges());
        //        }

        //        #endregion

        //        #endregion

        //        #region Footer

        //        WriteFooter();

        //        #endregion
        //    }
        //    catch (Exception e)
        //    {
        //        throw e;
        //    }
        //    finally
        //    {
        //        Shutdown();
        //    }
        //    return true;
        //}
    }
}
